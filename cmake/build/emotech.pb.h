// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: emotech.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_emotech_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_emotech_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_emotech_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_emotech_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_emotech_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_emotech_2eproto_metadata_getter(int index);
namespace emotech {
class ChunkRequest;
struct ChunkRequestDefaultTypeInternal;
extern ChunkRequestDefaultTypeInternal _ChunkRequest_default_instance_;
class ChunkResponse;
struct ChunkResponseDefaultTypeInternal;
extern ChunkResponseDefaultTypeInternal _ChunkResponse_default_instance_;
class IntRequest;
struct IntRequestDefaultTypeInternal;
extern IntRequestDefaultTypeInternal _IntRequest_default_instance_;
class IntResponse;
struct IntResponseDefaultTypeInternal;
extern IntResponseDefaultTypeInternal _IntResponse_default_instance_;
class StringRequest;
struct StringRequestDefaultTypeInternal;
extern StringRequestDefaultTypeInternal _StringRequest_default_instance_;
class StringResponse;
struct StringResponseDefaultTypeInternal;
extern StringResponseDefaultTypeInternal _StringResponse_default_instance_;
}  // namespace emotech
PROTOBUF_NAMESPACE_OPEN
template<> ::emotech::ChunkRequest* Arena::CreateMaybeMessage<::emotech::ChunkRequest>(Arena*);
template<> ::emotech::ChunkResponse* Arena::CreateMaybeMessage<::emotech::ChunkResponse>(Arena*);
template<> ::emotech::IntRequest* Arena::CreateMaybeMessage<::emotech::IntRequest>(Arena*);
template<> ::emotech::IntResponse* Arena::CreateMaybeMessage<::emotech::IntResponse>(Arena*);
template<> ::emotech::StringRequest* Arena::CreateMaybeMessage<::emotech::StringRequest>(Arena*);
template<> ::emotech::StringResponse* Arena::CreateMaybeMessage<::emotech::StringResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace emotech {

// ===================================================================

class IntRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.IntRequest) */ {
 public:
  inline IntRequest() : IntRequest(nullptr) {}
  virtual ~IntRequest();
  explicit constexpr IntRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntRequest(const IntRequest& from);
  IntRequest(IntRequest&& from) noexcept
    : IntRequest() {
    *this = ::std::move(from);
  }

  inline IntRequest& operator=(const IntRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntRequest& operator=(IntRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntRequest* internal_default_instance() {
    return reinterpret_cast<const IntRequest*>(
               &_IntRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IntRequest& a, IntRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IntRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntRequest* New() const final {
    return CreateMaybeMessage<IntRequest>(nullptr);
  }

  IntRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntRequest& from);
  void MergeFrom(const IntRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.IntRequest";
  }
  protected:
  explicit IntRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
  };
  // int32 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:emotech.IntRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// -------------------------------------------------------------------

class IntResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.IntResponse) */ {
 public:
  inline IntResponse() : IntResponse(nullptr) {}
  virtual ~IntResponse();
  explicit constexpr IntResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntResponse(const IntResponse& from);
  IntResponse(IntResponse&& from) noexcept
    : IntResponse() {
    *this = ::std::move(from);
  }

  inline IntResponse& operator=(const IntResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntResponse& operator=(IntResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntResponse* internal_default_instance() {
    return reinterpret_cast<const IntResponse*>(
               &_IntResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntResponse& a, IntResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IntResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntResponse* New() const final {
    return CreateMaybeMessage<IntResponse>(nullptr);
  }

  IntResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntResponse& from);
  void MergeFrom(const IntResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.IntResponse";
  }
  protected:
  explicit IntResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
  };
  // int32 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:emotech.IntResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// -------------------------------------------------------------------

class StringRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.StringRequest) */ {
 public:
  inline StringRequest() : StringRequest(nullptr) {}
  virtual ~StringRequest();
  explicit constexpr StringRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringRequest(const StringRequest& from);
  StringRequest(StringRequest&& from) noexcept
    : StringRequest() {
    *this = ::std::move(from);
  }

  inline StringRequest& operator=(const StringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRequest& operator=(StringRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringRequest* internal_default_instance() {
    return reinterpret_cast<const StringRequest*>(
               &_StringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StringRequest& a, StringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StringRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringRequest* New() const final {
    return CreateMaybeMessage<StringRequest>(nullptr);
  }

  StringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringRequest& from);
  void MergeFrom(const StringRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.StringRequest";
  }
  protected:
  explicit StringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestTextFieldNumber = 1,
  };
  // string requestText = 1;
  void clear_requesttext();
  const std::string& requesttext() const;
  void set_requesttext(const std::string& value);
  void set_requesttext(std::string&& value);
  void set_requesttext(const char* value);
  void set_requesttext(const char* value, size_t size);
  std::string* mutable_requesttext();
  std::string* release_requesttext();
  void set_allocated_requesttext(std::string* requesttext);
  private:
  const std::string& _internal_requesttext() const;
  void _internal_set_requesttext(const std::string& value);
  std::string* _internal_mutable_requesttext();
  public:

  // @@protoc_insertion_point(class_scope:emotech.StringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesttext_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// -------------------------------------------------------------------

class StringResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.StringResponse) */ {
 public:
  inline StringResponse() : StringResponse(nullptr) {}
  virtual ~StringResponse();
  explicit constexpr StringResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringResponse(const StringResponse& from);
  StringResponse(StringResponse&& from) noexcept
    : StringResponse() {
    *this = ::std::move(from);
  }

  inline StringResponse& operator=(const StringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringResponse& operator=(StringResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringResponse* internal_default_instance() {
    return reinterpret_cast<const StringResponse*>(
               &_StringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StringResponse& a, StringResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StringResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringResponse* New() const final {
    return CreateMaybeMessage<StringResponse>(nullptr);
  }

  StringResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringResponse& from);
  void MergeFrom(const StringResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.StringResponse";
  }
  protected:
  explicit StringResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseTextFieldNumber = 1,
  };
  // string responseText = 1;
  void clear_responsetext();
  const std::string& responsetext() const;
  void set_responsetext(const std::string& value);
  void set_responsetext(std::string&& value);
  void set_responsetext(const char* value);
  void set_responsetext(const char* value, size_t size);
  std::string* mutable_responsetext();
  std::string* release_responsetext();
  void set_allocated_responsetext(std::string* responsetext);
  private:
  const std::string& _internal_responsetext() const;
  void _internal_set_responsetext(const std::string& value);
  std::string* _internal_mutable_responsetext();
  public:

  // @@protoc_insertion_point(class_scope:emotech.StringResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsetext_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// -------------------------------------------------------------------

class ChunkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.ChunkRequest) */ {
 public:
  inline ChunkRequest() : ChunkRequest(nullptr) {}
  virtual ~ChunkRequest();
  explicit constexpr ChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkRequest(const ChunkRequest& from);
  ChunkRequest(ChunkRequest&& from) noexcept
    : ChunkRequest() {
    *this = ::std::move(from);
  }

  inline ChunkRequest& operator=(const ChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkRequest& operator=(ChunkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkRequest* internal_default_instance() {
    return reinterpret_cast<const ChunkRequest*>(
               &_ChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChunkRequest& a, ChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChunkRequest* New() const final {
    return CreateMaybeMessage<ChunkRequest>(nullptr);
  }

  ChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChunkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChunkRequest& from);
  void MergeFrom(const ChunkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.ChunkRequest";
  }
  protected:
  explicit ChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:emotech.ChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// -------------------------------------------------------------------

class ChunkResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:emotech.ChunkResponse) */ {
 public:
  inline ChunkResponse() : ChunkResponse(nullptr) {}
  virtual ~ChunkResponse();
  explicit constexpr ChunkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkResponse(const ChunkResponse& from);
  ChunkResponse(ChunkResponse&& from) noexcept
    : ChunkResponse() {
    *this = ::std::move(from);
  }

  inline ChunkResponse& operator=(const ChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkResponse& operator=(ChunkResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChunkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkResponse* internal_default_instance() {
    return reinterpret_cast<const ChunkResponse*>(
               &_ChunkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChunkResponse& a, ChunkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChunkResponse* New() const final {
    return CreateMaybeMessage<ChunkResponse>(nullptr);
  }

  ChunkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChunkResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChunkResponse& from);
  void MergeFrom(const ChunkResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "emotech.ChunkResponse";
  }
  protected:
  explicit ChunkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_emotech_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response();
  const std::string& response() const;
  void set_response(const std::string& value);
  void set_response(std::string&& value);
  void set_response(const char* value);
  void set_response(const char* value, size_t size);
  std::string* mutable_response();
  std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // @@protoc_insertion_point(class_scope:emotech.ChunkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emotech_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IntRequest

// int32 number = 1;
inline void IntRequest::clear_number() {
  number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRequest::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRequest::number() const {
  // @@protoc_insertion_point(field_get:emotech.IntRequest.number)
  return _internal_number();
}
inline void IntRequest::_internal_set_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_ = value;
}
inline void IntRequest::set_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:emotech.IntRequest.number)
}

// -------------------------------------------------------------------

// IntResponse

// int32 number = 1;
inline void IntResponse::clear_number() {
  number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntResponse::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntResponse::number() const {
  // @@protoc_insertion_point(field_get:emotech.IntResponse.number)
  return _internal_number();
}
inline void IntResponse::_internal_set_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_ = value;
}
inline void IntResponse::set_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:emotech.IntResponse.number)
}

// -------------------------------------------------------------------

// StringRequest

// string requestText = 1;
inline void StringRequest::clear_requesttext() {
  requesttext_.ClearToEmpty();
}
inline const std::string& StringRequest::requesttext() const {
  // @@protoc_insertion_point(field_get:emotech.StringRequest.requestText)
  return _internal_requesttext();
}
inline void StringRequest::set_requesttext(const std::string& value) {
  _internal_set_requesttext(value);
  // @@protoc_insertion_point(field_set:emotech.StringRequest.requestText)
}
inline std::string* StringRequest::mutable_requesttext() {
  // @@protoc_insertion_point(field_mutable:emotech.StringRequest.requestText)
  return _internal_mutable_requesttext();
}
inline const std::string& StringRequest::_internal_requesttext() const {
  return requesttext_.Get();
}
inline void StringRequest::_internal_set_requesttext(const std::string& value) {
  
  requesttext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StringRequest::set_requesttext(std::string&& value) {
  
  requesttext_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:emotech.StringRequest.requestText)
}
inline void StringRequest::set_requesttext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  requesttext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:emotech.StringRequest.requestText)
}
inline void StringRequest::set_requesttext(const char* value,
    size_t size) {
  
  requesttext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:emotech.StringRequest.requestText)
}
inline std::string* StringRequest::_internal_mutable_requesttext() {
  
  return requesttext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StringRequest::release_requesttext() {
  // @@protoc_insertion_point(field_release:emotech.StringRequest.requestText)
  return requesttext_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StringRequest::set_allocated_requesttext(std::string* requesttext) {
  if (requesttext != nullptr) {
    
  } else {
    
  }
  requesttext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesttext,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:emotech.StringRequest.requestText)
}

// -------------------------------------------------------------------

// StringResponse

// string responseText = 1;
inline void StringResponse::clear_responsetext() {
  responsetext_.ClearToEmpty();
}
inline const std::string& StringResponse::responsetext() const {
  // @@protoc_insertion_point(field_get:emotech.StringResponse.responseText)
  return _internal_responsetext();
}
inline void StringResponse::set_responsetext(const std::string& value) {
  _internal_set_responsetext(value);
  // @@protoc_insertion_point(field_set:emotech.StringResponse.responseText)
}
inline std::string* StringResponse::mutable_responsetext() {
  // @@protoc_insertion_point(field_mutable:emotech.StringResponse.responseText)
  return _internal_mutable_responsetext();
}
inline const std::string& StringResponse::_internal_responsetext() const {
  return responsetext_.Get();
}
inline void StringResponse::_internal_set_responsetext(const std::string& value) {
  
  responsetext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StringResponse::set_responsetext(std::string&& value) {
  
  responsetext_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:emotech.StringResponse.responseText)
}
inline void StringResponse::set_responsetext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  responsetext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:emotech.StringResponse.responseText)
}
inline void StringResponse::set_responsetext(const char* value,
    size_t size) {
  
  responsetext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:emotech.StringResponse.responseText)
}
inline std::string* StringResponse::_internal_mutable_responsetext() {
  
  return responsetext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StringResponse::release_responsetext() {
  // @@protoc_insertion_point(field_release:emotech.StringResponse.responseText)
  return responsetext_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StringResponse::set_allocated_responsetext(std::string* responsetext) {
  if (responsetext != nullptr) {
    
  } else {
    
  }
  responsetext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), responsetext,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:emotech.StringResponse.responseText)
}

// -------------------------------------------------------------------

// ChunkRequest

// bytes content = 2;
inline void ChunkRequest::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ChunkRequest::content() const {
  // @@protoc_insertion_point(field_get:emotech.ChunkRequest.content)
  return _internal_content();
}
inline void ChunkRequest::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:emotech.ChunkRequest.content)
}
inline std::string* ChunkRequest::mutable_content() {
  // @@protoc_insertion_point(field_mutable:emotech.ChunkRequest.content)
  return _internal_mutable_content();
}
inline const std::string& ChunkRequest::_internal_content() const {
  return content_.Get();
}
inline void ChunkRequest::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChunkRequest::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:emotech.ChunkRequest.content)
}
inline void ChunkRequest::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:emotech.ChunkRequest.content)
}
inline void ChunkRequest::set_content(const void* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:emotech.ChunkRequest.content)
}
inline std::string* ChunkRequest::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChunkRequest::release_content() {
  // @@protoc_insertion_point(field_release:emotech.ChunkRequest.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChunkRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:emotech.ChunkRequest.content)
}

// -------------------------------------------------------------------

// ChunkResponse

// string response = 1;
inline void ChunkResponse::clear_response() {
  response_.ClearToEmpty();
}
inline const std::string& ChunkResponse::response() const {
  // @@protoc_insertion_point(field_get:emotech.ChunkResponse.response)
  return _internal_response();
}
inline void ChunkResponse::set_response(const std::string& value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:emotech.ChunkResponse.response)
}
inline std::string* ChunkResponse::mutable_response() {
  // @@protoc_insertion_point(field_mutable:emotech.ChunkResponse.response)
  return _internal_mutable_response();
}
inline const std::string& ChunkResponse::_internal_response() const {
  return response_.Get();
}
inline void ChunkResponse::_internal_set_response(const std::string& value) {
  
  response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChunkResponse::set_response(std::string&& value) {
  
  response_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:emotech.ChunkResponse.response)
}
inline void ChunkResponse::set_response(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:emotech.ChunkResponse.response)
}
inline void ChunkResponse::set_response(const char* value,
    size_t size) {
  
  response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:emotech.ChunkResponse.response)
}
inline std::string* ChunkResponse::_internal_mutable_response() {
  
  return response_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChunkResponse::release_response() {
  // @@protoc_insertion_point(field_release:emotech.ChunkResponse.response)
  return response_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChunkResponse::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    
  } else {
    
  }
  response_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:emotech.ChunkResponse.response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace emotech

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_emotech_2eproto
